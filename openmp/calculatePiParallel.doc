/***************************************************************************
 * FILE: omp_pi_calc.c
 * DESCRIPTION:  
 *   Parallel pi Calculation - OpenMP Version - C Version
 *   This program calculates pi using a "dartboard" algorithm.  See
 *   Fox et al.(1988) Solving Problems on Concurrent Processors, vol.1
 *   page 207.  
 *   PARALLELIZED: The dart throwing loop is parallelized using OpenMP
 * AUTHOR: modified for OpenMP
 * REVISED: 02/23/12 Blaise Barney
***************************************************************************/
#include <stdio.h>
#include <stdlib.h>
#include <omp.h>

void srandom (unsigned seed);  
double dboard (int darts);

#define DARTS 10000   	/* number of throws at dartboard */
#define ROUNDS 100    	/* number of times "darts" is iterated */

int main(int argc, char *argv[])
{
double pi;          	/* average of pi after "darts" is thrown */
double avepi;       	/* average pi value for all iterations */
int i, n;

printf("Starting PARALLEL version of pi calculation using dartboard algorithm...\n");
srandom (5);            /* seed the random number generator */
avepi = 0;
for (i = 0; i < ROUNDS; i++) {
   /* Perform pi calculation on parallel processor */
   pi = dboard(DARTS);
   avepi = ((avepi * i) + pi)/(i + 1); 
   printf("   After %3d throws, average value of pi = %10.8f\n",
         (DARTS * (i + 1)),avepi);
   }    
printf("\nReal value of PI: 3.1415926535897 \n");
}

/*****************************************************************************
 * dboard - PARALLELIZED VERSION
 *****************************************************************************/
#define sqr(x)	((x)*(x))
long random(void);

double dboard(int darts)
{
   double x_coord,       /* x coordinate, between -1 and 1  */
          y_coord,       /* y coordinate, between -1 and 1  */
          pi,            /* pi  */
          r;             /* random number scaled between 0 and 1  */
   int score,            /* number of darts that hit circle */
       n;
   unsigned int cconst;  /* must be 4-bytes in size */
/*************************************************************************
 * The cconst variable must be 4 bytes. We check this and bail if it is
 * not the right size
 ************************************************************************/
   if (sizeof(cconst) != 4) {
      printf("Wrong data size for cconst variable in dboard routine!\n");
      printf("See comments in source file. Quitting.\n");
      exit(1);
      }
   /* 2 bit shifted to MAX_RAND later used to scale random number between 0 and 1 */
   cconst = 2 << (31 - 1);
   score = 0;

/***********************************************************************
 * Throw darts at board USING OPENMP PARALLELIZATION
 * The dart throwing loop is parallelized.
 * Each thread throws its share of darts and counts hits.
 * reduction(+:score) safely combines all thread counts at the end.
 ************************************************************************/

   #pragma omp parallel for private(r, x_coord, y_coord, n) reduction(+:score)
   for (n = 1; n <= darts; n++) {
      /* generate random numbers for x and y coordinates */
      r = (double)random()/cconst;
      x_coord = (2.0 * r) - 1.0;
      r = (double)random()/cconst;
      y_coord = (2.0 * r) - 1.0;

      /* if dart lands in circle, increment score */
      if ((sqr(x_coord) + sqr(y_coord)) <= 1.0)
         score++;
      }

   /* calculate pi */
   pi = 4.0 * (double)score/(double)darts;
   return(pi);
}



key changes

#pragma omp parallel for private(r, x_coord, y_coord, n) reduction(+:score)
for (n = 1; n <= darts; n++) {
   // ... dart throwing logic ...
   if ((sqr(x_coord) + sqr(y_coord)) <= 1.0)
      score++;
}


Why This Works:

#pragma omp parallel for — Distributes the 10,000 dart throws across all available threads

private(r, x_coord, y_coord, n) — Each thread gets its own copies of these variables (no conflicts)

reduction(+:score) — Each thread counts hits in its private score, then the final thread counts are added together

Example with 4 threads, 10,000 darts:

Thread 0 throws darts 0-2,499, counts hits → score_0
Thread 1 throws darts 2,500-4,999, counts hits → score_1
Thread 2 throws darts 5,000-7,499, counts hits → score_2
Thread 3 throws darts 7,500-9,999, counts hits → score_3
Final: score = score_0 + score_1 + score_2 + score_3